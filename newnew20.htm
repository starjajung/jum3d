<!doctype html>
<html lang="euc-kr">
	<head>
		<title>3D그림판</title>
	
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <center>

             <audio id="player" src="bgm/bg2.mp3" controls="true" loop="true" autoplay="true"> </audio>
   <button onclick="document.getElementById('player').volume += 0.1">Vol+ </button> 
    <button onclick="document.getElementById('player').volume -= 0.1">Vol- </button> 
       </center>


       




	<center>
	   		 <div>
<a href="newnew10.htm" target="_top"><button onclick= "if(!confirm('모든 블럭이 지워집니다. \n계속하시겠습니까?'))return false;">10 by 10</button></a>
<a href="newnew40.htm" target="_top"><button onclick= "if(!confirm('모든 블럭이 지워집니다. \n계속하시겠습니까?'))return false;">40 by 40</button></a>
<a href="newnew50.htm" target="_top"><button onclick= "if(!confirm('모든 블럭이 지워집니다. \n계속하시겠습니까?'))return false;">50 by 50</button></a>
<a href="newnew100.htm" target="_top"><button onclick= "if(!confirm('모든 블럭이 지워집니다. \n계속하시겠습니까?'))return false;">100 by 100</button></a>

            </div>
     </center>

	 	   <center>
       (도움말 - 색깔 변경)
          흰색=0, 빨강색=1, 주황색=2, 노랑색=3, 초록색=4, 파랑색=5, 남색=6, 보라색=7, 검정색=8, 회색 = 9  
         
 </center>
   <center>
<strong>click</strong>: add voxel, <strong>control + click</strong>: remove voxel, <strong>shift + click</strong>: rotate, <a href="javascript:save();return false;">save .png</a>
 </center>

		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				
			}

			#oldie { background-color: #ddd !important }<u></u>
		</style>



	</head>
	<body oncontextmenu="return false" onselectstart="return false" ondragstart="return false">

		<script src="Three.js"></script>

		<script src="Detector.js"></script>
      <script src="Stats.js"></script>

		<script src='DAT.GUI.min.js'></script>

		<script>


    




          

		          var save_num =  [ {"shadow":100, "floor" :10, "position":50 },
			                                 {"shadow":50, "floor" :20, "position":25 },
											 {"shadow":25, "floor" :40, "position":12.5 },
											 {"shadow":20, "floor" :50, "position":10 },
											 {"shadow":10, "floor" :100, "position":5 } ];   //숫자 저장 
  
            

			   var shadow;
			   var floor;
			   var position;



	floorSize(20);//사이즈가 10 by 10 일경우 ... 

		  function floorSize(floors){  //바닥 사이즈 크키 변경 메소드 
   var floor_size = floors;
				//  window.location.reload();
		     
					console.log(floors);


				 if(floor_size==10){  // 판사이즈에 맞게 값이 자유자재로 저장!!
			     
				 shadow =  save_num[0].shadow;
				 floor = save_num[0].floor;
				 position = save_num[0].position;
 
                
				 }
				 else if(floor_size==20){
          
		          shadow =  save_num[1].shadow;
				  floor = save_num[1].floor;
               position = save_num[1].position;

				 }
				 else if(floor_size==40){

				  shadow =  save_num[2].shadow;
			      floor = save_num[2].floor;
				   position = save_num[2].position;

				 }
				 else if(floor_size==50){

				  shadow =  save_num[3].shadow;
				 floor = save_num[3].floor;
				 position = save_num[3].position;

				 }
				  else if(floor_size==100){

			    shadow =  save_num[4].shadow;
			    floor = save_num[4].floor;
               position = save_num[4].position;

				 }




};

//}

         
	


		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			//var = 텍스트의 변수 부분을 정의
			var container, stats;
			var camera, cameraTarget, scene, renderer;
			var projector, plane, cube;
			var mouse2D, mouse3D, ray,
			rollOveredFace, isShiftDown = false,is1Down = false,is2Down = false,is3Down = false,is4Down = false, is5Down = false,is6Down = false,is7Down = false,is8Down = false,is9Down = false,is0Down = false,
			theta = 45, isCtrlDown = false;

			var rollOverMesh, rollOverMaterial, voxelPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3();
			var cubeGeo, cubeMaterial;
			var i, intersector;

			var gui, voxelConfig = {
				orthographicProjection: false
			};

			//진짜시작하는곳 init(); -> animate();

			init();
			animate();

			function init() {
				
            //새로운 div 엘리먼트를 만든다.
				container = document.createElement( 'div' );
				//body 자식노드로 생성
				document.body.appendChild( container );

				//새로운 div 엘리먼트를 만든다.
				var info = document.createElement( 'div' );
			
				
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';

				
				//Inserts an element after the last child of the current element.
				container.appendChild( info );

				//우리가 만든 것들을 포함할 Scene을 만듬
				scene = new THREE.Scene();
				//Scene을 어떤 식으로 바라 볼지 Camera를 만듬

				//CombinedCamera는 카메라 보는 위치를 다방면으로 볼수있다? EX) fov, left, right, top. bottom, cameraO, cameraP, zoom, near, far, projectionMatrix, inPersepectiveMove, inOrthographicMode, rotationAutoUpdate
				// 76~80줄이 CombinedCamera생성할때 필요한것 같음. 
				camera = new THREE.CombinedCamera( window.innerWidth, window.innerHeight, 45, 1, 10000, -2000, 10000 );
				camera.position.y = 800;
				scene.add( camera );

				cameraTarget = new THREE.Vector3( 0, 0, 0 );


          
                 
				
				// roll-over helpers
			
					//큐브 그림자 size 100cm인 정사각형
				rollOverGeo = new THREE.CubeGeometry(shadow,shadow,shadow); //1.*******/
				//그림자색깔 color: 0xff0000


				
				rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
				rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
				scene.add( rollOverMesh );

				  // random기능을 선언합니다.
            var random = function (limit) {
                return Math.round(Math.random() * limit);
            };
				
				// cubes
				//진짜 큐브 size 100cm인 정사각형
	 		cubeGeo = new THREE.CubeGeometry(shadow,shadow,shadow);//2.*****/
				//그림자색깔 color는 새로고침 할때마다 random으로 생성
			//	cubeMaterial = new THREE.MeshLambertMaterial( { color: andom(0xFFFFFF), ambient: random(0xFFFFFF), emissive: random(0xFFFFFF)} );
											  
				cubeMaterial = new THREE.MeshLambertMaterial( { color: "0xff0000"} );

				
				
				//setHSV  색상을 지정해 준다.





				cubeMaterial.color.setHSV(0xff0000);
				
			cubeMaterial.ambient = cubeMaterial.color;


				
          


				// picking

				projector = new THREE.Projector();

				// grid
				//PlaneGeometry( 1200, 1200, 10, 10 ) 1200 * 1200 에서 10 *10개의 바둑판 생성
				//바둑판 색깔 color: 0x555555 , wireframe: true 바둑판 생성됨.
				plane = new THREE.Mesh(new THREE.PlaneGeometry( 1000, 1000, floor, floor ), new THREE.MeshBasicMaterial( { color: 0x000000,opacity: 0.5, wireframe:
				true } ) );                       /*3.******/
				//scene에 바둑판 박아버려.
				scene.add( plane );
				
/* 

2012년 8월 2일 목요일 요기서부터 시작합시다. 

*/

				mouse2D = new THREE.Vector3( 0, 10000, 0.5 );

				// Lights

				var ambientLight = new THREE.AmbientLight( 0x606060 );
				scene.add( ambientLight );

				var directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer : true } );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );

				// add GUI
				gui = new DAT.GUI();
				gui.add(voxelConfig, 'orthographicProjection').onChange(function(){

				if ( voxelConfig.orthographicProjection ) {
					camera.toOrthographic();
					camera.position.x = 100;
              			camera.position.y = 707.106;
               		camera.position.z = 500;
						theta = 90;
					} else {
						camera.toPerspective();
						camera.position.y = 800;
				}

				});
			gui.close();

			}

		

			function getRealIntersector( intersects ) {

				for( i = 0; i < intersects.length; i++ ) {

					intersector = intersects[ i ];

					if ( intersector.object != rollOverMesh ) {

						return intersector;

					}

				}

				return null;

			}


			function setVoxelPosition( intersector ) {
	
				tmpVec.copy( intersector.face.normal );
				
	

				voxelPosition.add( intersector.point, intersector.object.matrixRotationWorld.multiplyVector3( tmpVec ) );

				voxelPosition.x = Math.floor( voxelPosition.x / shadow) * shadow + position;  
				voxelPosition.y = Math.floor( voxelPosition.y / shadow) *  shadow + position;
				voxelPosition.z = Math.floor( voxelPosition.z / shadow) *  shadow + position;
				
                 

				

			}


			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse2D.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse2D.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				var intersects = ray.intersectObjects( scene.children );

				if ( intersects.length > 0 ) {

					intersector = getRealIntersector( intersects );

					// delete cube

					if ( isCtrlDown ) {

						if ( intersector.object != plane ) {

							scene.remove( intersector.object );

						}

					// create cube

					} else {

						intersector = getRealIntersector( intersects );
						setVoxelPosition( intersector );

						var voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
						voxel.position.copy( voxelPosition );
						voxel.matrixAutoUpdate = false;
						voxel.updateMatrix();
						scene.add( voxel );

					}

				}
				if(is0Down)
					{							  
						cubeMaterial = new THREE.MeshLambertMaterial( { color: "0xFFFFFF"} );
					} 
				if(is1Down)
					{							  
						cubeMaterial = new THREE.MeshLambertMaterial( { color: "0xFF0000"} );
					} 
				if(is2Down)
					{
						cubeMaterial = new THREE.MeshLambertMaterial( { color: "0xFF8000"} );
					}
				if(is3Down)
					{
						cubeMaterial = new THREE.MeshLambertMaterial( { color: "0xF7FE2E"} );
					}
				if (is4Down)
					{
						cubeMaterial = new THREE.MeshLambertMaterial( { color: "0x04B404"} );
					}
				if (is5Down)
					{
						cubeMaterial = new THREE.MeshLambertMaterial( { color: "0x0040FF"} );
					}
				if (is6Down)
					{
						cubeMaterial = new THREE.MeshLambertMaterial( { color: "0x0B2161"} );
					}
				if (is7Down)
					{
						cubeMaterial = new THREE.MeshLambertMaterial( { color: "0x8904B1"} );
					}
				if (is8Down)
					{
						cubeMaterial = new THREE.MeshLambertMaterial( { color: "0xFA58F4"} );
					}
				if (is9Down)
					{
						cubeMaterial = new THREE.MeshLambertMaterial( { color: "0x000000"} );
					}
			}

			function onDocumentKeyDown( event ) {
				console.log(event.keyCode);
				switch( event.keyCode ) {

					case 16: isShiftDown = true; break;
					case 17: isCtrlDown = true; break;
					case 48: is0Down = true; break;
					case 49: is1Down = true; break;
					case 50: is2Down = true; break;
					case 51: is3Down = true; break;
					case 52: is4Down = true; break;
					case 53: is5Down = true; break;
					case 54: is6Down = true; break;
					case 55: is7Down = true; break;
					case 56: is8Down = true; break;
					case 57: is9Down = true; break;


				}

			}

			function onDocumentKeyUp( event ) {

				switch( event.keyCode ) {

					case 16: isShiftDown = false; break;
					case 17: isCtrlDown = false; break;
					case 48: is0Down = true; break;
					case 49: is1Down = true; break;
					case 50: is2Down = true; break;
					case 51: is3Down = true; break;
					case 52: is4Down = true; break;
					case 53: is5Down = true; break;
					case 54: is6Down = true; break;
					case 55: is7Down = true; break;
					case 56: is8Down = true; break;
					case 57: is9Down = true; break;
				}
			}

			function save() {

				window.open( renderer.domElement.toDataURL('image/png'), 'mywindow' );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				if ( isShiftDown ) {

					theta += mouse2D.x * 3;

				}

				ray = projector.pickingRay( mouse2D.clone(), camera );

				var intersects = ray.intersectObjects( scene.children );

				if ( intersects.length > 0 ) {

					intersector = getRealIntersector( intersects );
					if ( intersector ) {

						setVoxelPosition( intersector );
						rollOverMesh.position = voxelPosition;

					}

				}

				camera.position.x = 1400 * Math.sin( theta * Math.PI / 360 );
				camera.position.z = 1400 * Math.cos( theta * Math.PI / 360 );

				camera.lookAt( cameraTarget );

				renderer.render( scene, camera );

			}
			



		</script>

	</body>
</html>
